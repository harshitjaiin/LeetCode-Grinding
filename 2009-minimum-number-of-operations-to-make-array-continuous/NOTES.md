In this question basically. we have to make all elements unique once. the difference between the maximum and the minimum variant should be one less than the iris size when you just apply both of these conditions to any particular array, you will find that when the array satisfies both of these conditions are only when the difference between all of the elements like all of the continuous elements are 1. Basically, when you sort the array, the difference between all of the adjacent elements comes out to be 1. So this is basically what a questions want us to do.
​
Now coming onto how we do it basically. we will just start with a particular element. We'll pick it, we'll find if this element is fixed as the lowest point, what will be the highest point, which will be addition of array of array size minus 1. So we will just now run a loop again and find the elements which are outside this range. All the element which are outside this range has to be brought to this range. And this will require one operation, each for all the elements, which. do not come in the range. So this can be done in linear time and a time complexity for the solution would be O of N Square.
​
But in this case, we weren't handling the duplicates case. So for handling all the duplicates, we'll just make sure that we maintain. a map which tells us that, yeah, this particular element has been taken once. If the same element repeats itself again, then it definitely has to change whether it is in the range or it is outside the range. So for that we are maintaining a map. And that solution, you can find it the submissions part. It will be as runtime error or like time limit exceeded something.
​
Now we'll have to optimize it So just a point that. I mentioned about that after all the operations have been done and the array is continuous. When we sort the array, it is in the continuous fashion, like 3456 something like that. So we just sort the array in the beginning, and we pick one element like we did in the brute force solution. We pick the element. We also get the Mac range. Final element. Now, using the upper bound, we can find out the elements which are outside the range in. the right sides. Because for the left side you already know if we are on the index I then all the elements from zero to I are outside the range. So we do not have to calculate it again and again. So we just have to calculate the upper bound. Now using the upper bound, we can get the index and number of elements respectively which are on the other side which we have to particular perform an operation. So that will be included in the answer. also we are actually after before or after sorting we can do that also we are actually after before or after sorting we can do that all the elements are basically maintain a set. So we do not even consider all the elements which are in the duplicacy form.